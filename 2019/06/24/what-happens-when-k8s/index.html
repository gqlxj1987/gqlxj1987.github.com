<!DOCTYPE html><html lang="zh-CN"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="generator" content="Astro v4.16.19"><title>Blog</title><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=JetBrains+Mono&display=swap" rel="stylesheet"><style>:root{--primary: #2563eb;--text-main: #1f2937;--text-muted: #6b7280;--bg-main: #ffffff;--bg-secondary: #f9fafb;--border: #e5e7eb;--max-width: 800px;--font-sans: "Inter", system-ui, -apple-system, sans-serif;--font-mono: "JetBrains Mono", monospace}*{margin:0;padding:0;box-sizing:border-box}body{font-family:var(--font-sans);color:var(--text-main);background-color:var(--bg-main);line-height:1.6;-webkit-font-smoothing:antialiased}.app-container{display:flex;flex-direction:column;min-height:100vh}.navbar{border-bottom:1px solid var(--border);position:sticky;top:0;background:#fffc;backdrop-filter:blur(8px);z-index:100}.nav-content{max-width:var(--max-width);margin:0 auto;padding:1rem;display:flex;justify-content:space-between;align-items:center}.logo{text-decoration:none;color:var(--text-main);font-weight:800;font-size:1.5rem}.nav-links{list-style:none;display:flex;gap:1.5rem}.nav-links a{text-decoration:none;color:var(--text-muted);font-size:.95rem;font-weight:500;transition:color .2s}.nav-links a:hover{color:var(--primary)}.main-content{flex:1;max-width:var(--max-width);margin:0 auto;width:100%;padding:3rem 1rem}.footer{border-top:1px solid var(--border);background:var(--bg-secondary);padding:2rem 1rem;margin-top:4rem}.footer-content{max-width:var(--max-width);margin:0 auto;text-align:center;color:var(--text-muted);font-size:.9rem}.post-content h1,.post-content h2,.post-content h3{margin-top:2.5rem;margin-bottom:1rem;line-height:1.3}.post-content p{margin-bottom:1.5rem}.post-content img{max-width:100%;height:auto;border-radius:8px;margin:2rem 0}.post-content pre{border-radius:8px;padding:1.25rem;margin-bottom:2rem;font-family:var(--font-mono);font-size:.9rem;overflow-x:auto}.post-content code:not(pre code){background:var(--bg-secondary);padding:.2rem .4rem;border-radius:4px;font-family:var(--font-mono);font-size:.9em}.post-content blockquote{border-left:4px solid var(--primary);padding-left:1.5rem;font-style:italic;color:var(--text-muted);margin:2rem 0}.post-content ul,.post-content ol{margin-bottom:1.5rem;padding-left:1.5rem}.post-content li{margin-bottom:.5rem}
.post-header[data-astro-cid-rl3favg5]{margin-bottom:4rem;text-align:center}.post-date[data-astro-cid-rl3favg5]{display:block;font-size:.875rem;text-transform:uppercase;letter-spacing:.05em;color:var(--text-muted);font-weight:600;margin-bottom:1rem}.post-title[data-astro-cid-rl3favg5]{font-size:3rem;font-weight:800;line-height:1.1;margin-bottom:1.5rem;letter-spacing:-.025em}.post-meta[data-astro-cid-rl3favg5]{display:flex;justify-content:center;gap:1.5rem;font-size:.95rem;color:var(--text-muted)}.tag[data-astro-cid-rl3favg5]{color:var(--primary);margin-right:.5rem}@media (max-width: 640px){.post-title[data-astro-cid-rl3favg5]{font-size:2rem}}
</style></head> <body> <div class="app-container"> <header class="navbar"> <div class="nav-content"> <a href="/" class="logo"> <span class="logo-text">Blog</span> </a> <nav> <ul class="nav-links"> <li><a href="/">Home</a></li> <li><a href="/archive">Archive</a></li> <li><a href="/about">About</a></li> </ul> </nav> </div> </header> <main class="main-content">  <article class="post" data-astro-cid-rl3favg5> <header class="post-header" data-astro-cid-rl3favg5> <time class="post-date" data-astro-cid-rl3favg5> June 24, 2019 </time> <h1 class="post-title" data-astro-cid-rl3favg5></h1> <div class="post-meta" data-astro-cid-rl3favg5>   </div> </header> <div class="post-content" data-astro-cid-rl3favg5> <p>title : What Happens When K8s
date : 2019-06-24 14:30:01
categories : kubernets
tags : [kubernets]</p>
<hr>
<p><a href="https://github.com/jamiehannaford/what-happens-when-k8s">原文链接</a></p>
<p>kubect->kube apiserver->etcd->initializer->control loops->kubelet->wrap up</p>
<h3 id="kubect">kubect</h3>
<p>validation and generators -> api groups and version negotiation-> client auth</p>
<p>All attempts to access or change state in the Kubernetes system goes through the API server, which in turns communicates with etcd.</p>
<p>What’s worth pointing out before we continue is that Kubernetes uses a <em>versioned</em> API that is categorised into “API groups”. An API group is meant to categorise similar resources so that they’re easier to reason about.</p>
<p>After kubectl generates the runtime object, it starts to <a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L580-L597">find the appropriate API group and version</a> for it and then <a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/kubectl/cmd/run.go#L598">assembles a versioned client</a> that is aware of the various REST semantics for the resource.自动发现机制？</p>
<h3 id="kube-apiserver">kube-apiserver</h3>
<p>authentication-> authorization->admission control</p>
<p>As we’ve already mentioned, kube-apiserver is the primary interface that clients and system components use to persist and retrieve cluster state. To perform its function, it needs to be able to verify that the requester is who they say there are. This process is called authentication.</p>
<p>Whilst authorization is focused on answering whether a user has permission, admission controllers intercept the request to ensure that it matches the wider expectations and rules of the cluster.</p>
<p>Admission controllers:</p>
<ul>
<li>InitialResources</li>
<li>LimitRanger</li>
<li>ResourceQuota</li>
</ul>
<h3 id="etcd">etcd</h3>
<p>Well, there’s a pretty complicated series of steps that happen <em>before</em> any requests are served.</p>
<ol>
<li>When the <code>kube-apiserver</code> binary is run, it <a href="https://github.com/kubernetes/kubernetes/blob/master/cmd/kube-apiserver/app/server.go#L119">creates a server chain</a>, which allows apiserver aggregation. This is basically a way of supporting multiple apiservers (we don’t need to worry about this).</li>
<li>When this happens, a <a href="https://github.com/kubernetes/kubernetes/blob/master/cmd/kube-apiserver/app/server.go#L149">generic apiserver is created</a> that serves as a default implementation.</li>
<li>The generated OpenAPI schema populates the <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/server/config.go#L149">apiserver’s configuration</a>.</li>
<li>kube-apiserver then iterates over all the API groups specified in the schema and configures a <a href="https://github.com/kubernetes/kubernetes/blob/c7a1a061c3dc5acabcc0c35b3b96a6935dccf546/pkg/master/master.go#L410">storage provider</a> for each that serves as a generic storage abstraction. This is what kube-apiserver talks to when it accesses or mutates the state of a resource.</li>
<li>For every API group it also iterates over each of the group versions and <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/groupversion.go#L92">installs the REST mappings</a> for every HTTP route. This allows kube-apiserver to map requests and be able to delegate off to the correct logic once it finds a match.</li>
<li>For our specific use case, a <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/installer.go#L710">POST handler</a> is registered, which in turn will delegate to a <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L37">create resource handler</a>.</li>
</ol>
<p>Now let’s imagine our HTTP request has flown in:</p>
<ol>
<li>If the handler chain can match the request to a set pattern (i.e. to the routes we registered), it will <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/server/handler.go#L143">dispatch the dedicated handler</a> that was registered for the route. Otherwise it fall back to a <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/server/mux/pathrecorder.go#L248">path-based handler</a> (this is what happens when you call <code>/apis</code>). If no handlers are registered for that path, a <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/server/mux/pathrecorder.go#L254">not found handler</a> is invoked which results in a 404.</li>
<li>Luckily for us, we have a registered route called <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L37"><code>createHandler</code></a>! What does it do? Well it will first decode the HTTP request and perform basic validation, such as ensuring the JSON they provided correlates with our expectation of the versioned API resource.</li>
<li>Auditing and final admission <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L93-L104">will occur</a>.</li>
<li>The resource will be <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L111">saved to etcd</a> by <a href="https://github.com/kubernetes/apiserver/blob/19667a1afc13cc13930c40a20f2c12bbdcaaa246/pkg/registry/generic/registry/store.go#L327">delegating to the storage provider</a>. Usually the etcd key will be the form of <code>&#x3C;namespace>/&#x3C;name></code>, but this is configurable.</li>
<li>Any create errors are caught and, finally, the storage provider performs a <code>get</code> call to ensure the object was actually created. It then invokes any post-create handlers and decorators if additional finalization is required.</li>
<li>The HTTP response <a href="https://github.com/kubernetes/apiserver/blob/7001bc4df8883d4a0ec84cd4b2117655a0009b6c/pkg/endpoints/handlers/create.go#L131-L142">is constructed</a> and sent back.</li>
</ol>
<h3 id="initializers">initializers</h3>
<p>An initializer is a controller that is associated with a resource type and performs logic on the resource before it’s made available to the outside world</p>
<p><code>initializerConfiguration</code> objects allow you to declare which initializers should run for certain resource types. After creating this config, it will append <code>custom-pod-initializer</code> to every Pod’s <code>metadata.initializers.pending</code> field.</p>
<h3 id="control-loops">Control loops</h3>
<p>deployments controller-> replicaSets controller-> informers -> scheduler</p>
<p>When we think about it, a Deployment is really just a collection of ReplicaSets, and a ReplicaSet is a collection of Pods.</p>
<p>This handler will be executed when our Deployment first becomes available and will start by <a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/deployment/deployment_controller.go#L170">adding the object to an internal work queue</a>.</p>
<p>it will begin a <a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/controller/deployment/sync.go#L385">scaling process</a> to start resolving state. It does this by rolling out (e.g. creating) a ReplicaSet resource, assigning it a label selector, and giving it the revision number of 1. label selector?</p>
<p>the Deployments controller created our Deployment’s first ReplicaSet but we still have no Pods. This is where the ReplicaSet controller comes into play! Its job is to monitor the lifecycle of ReplicaSets and their dependent resources (Pods). Like most other controllers, it does this by triggering handlers on certain events</p>
<p>Kubernetes enforces object hierarchies through Owner References (a field in the child resource where it references the ID of its parent).</p>
<p>An informer is a pattern that allows controllers to subscribe to storage events and easily list resources they’re interested in.</p>
<p>Apart from providing an abstraction which is nice to work with, it also takes care of a lot of the nuts and bolts such as caching (caching is important because it reduces unnecessary kube-apiserver connections, and reduces duplicate serialization costs server- and controller-side).关于caching的含义？消息应该不能用cache才对</p>
<p>What’s interesting is that both predicate and priority functions are extensible and can be defined by using the <code>--policy-config-file</code> flag. This introduces a degree of flexibility. 调度的灵活性</p>
<h3 id="kubelet">kubelet</h3>
<p>pod sync-> CRI and pause containers-> cni and pod networking-> inter-host networking-> container startup</p>
<p>The kubelet is an agent that runs on every node in a Kubernetes cluster and is responsible for, among other things, managing the lifecycle of Pods.</p>
<p>A useful way of thinking about the kubelet is again like a controller! It queries Pods from kube-apiserver every 20 seconds (this is configurable), filtering the ones whose <code>NodeName</code> <a href="https://github.com/kubernetes/kubernetes/blob/3b66adb8bc6929e1205bcb2bc32f380c39be8381/pkg/kubelet/config/apiserver.go#L34">matches the name</a> of the node the kubelet is running on. Once it has that list, it detects new additions by comparing against its own internal cache and begins to synchronise state if any discrepencies exist.</p>
<p>In this runtime, creating a sandbox involves creating a “pause” container. A pause container serves like a parent for all of the other containers in the Pod since it hosts a lot of the pod-level resources that workload containers will end up using.</p>
<p>The “pause” container provides a way to host all of these namespaces and allow child containers to share them.</p>
<h3 id="wrap-up">Wrap-up</h3> </div> </article>  </main> <footer class="footer"> <div class="footer-content"> <p>&copy; 2026 Liu Weifeng. Built with Astro.</p> </div> </footer> </div> </body></html> 