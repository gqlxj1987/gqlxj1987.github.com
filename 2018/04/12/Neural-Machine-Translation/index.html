<!DOCTYPE html><html lang="zh-CN"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="generator" content="Astro v4.16.19"><meta name="description" content="Blog post"><title>Untitled</title><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Lora:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet"><link rel="stylesheet" href="/_astro/_title_.U5p-WJ3X.css"><script type="module">const e=()=>{document.querySelectorAll(".animate").forEach((t,s)=>{setTimeout(()=>{t.classList.add("show")},s*150)})};e();document.addEventListener("astro:after-swap",e);
</script></head> <body> <header> <div class="mx-auto max-w-screen-sm px-5">  <div class="flex flex-wrap gap-y-2 justify-between"> <a href="/" class="font-semibold hover:underline underline-offset-2">
Blog
</a> <nav class="flex gap-1">  <a href="/archive" class="hover:underline underline-offset-2"> Archive </a> <span>/</span> <a href="/tags" class="hover:underline underline-offset-2"> Tags </a> <span>/</span> <a href="/categories" class="hover:underline underline-offset-2"> Categories </a> <span>/</span> <a href="/about" class="hover:underline underline-offset-2"> About </a>  </nav> </div>  </div> </header> <main>  <div class="mx-auto max-w-screen-sm px-5">  <div class="animate"> <a href="/archive" class="hover:underline underline-offset-2">
← Back to archive
</a> </div> <div class="space-y-1 my-10"> <div class="animate flex items-center gap-1.5"> <div class="font-base text-sm"> <time datetime="2018-04-12T00:00:00.000Z"> April 12, 2018 </time> </div> </div> <div class="animate text-2xl font-semibold text-black dark:text-white">  </div>  </div> <article class="animate"> <h2 id="title-neural-machine-translationdate-2018-04-12-150835categories-mltags-ml">title: Neural Machine Translation
date: 2018-04-12 15:08:35
categories: ML
tags: [ML]</h2>
<p><a href="https://github.com/tensorflow/nmt#background-on-neural-machine-translation">repo</a></p>
<h2 id="数据预处理">数据预处理</h2>
<p><a href="https://xiaozhuanlan.com/topic/5841967302">原文链接</a></p>
<p>使用了新的Dataset API部分</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="python"><code><span class="line"><span style="color:#E1E4E8">src_dataset</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">tf.data.TextLineDataset(</span><span style="color:#9ECBFF">'src_data.txt'</span><span style="color:#E1E4E8">)  </span></span>
<span class="line"><span style="color:#E1E4E8">tgt_dataset</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">tf.data.TextLineDataset(</span><span style="color:#9ECBFF">'tgt_data.txt'</span><span style="color:#E1E4E8">)  </span></span>
<span class="line"></span></code></pre>
<p>查找表的构造方法：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="python"><code><span class="line"><span style="color:#F97583">def</span><span style="color:#B392F0"> create_vocab_tables</span><span style="color:#E1E4E8">(src_vocab_file, tgt_vocab_file, share_vocab):</span></span>
<span class="line"><span style="color:#9ECBFF">  """Creates vocab tables for src_vocab_file and tgt_vocab_file."""</span></span>
<span class="line"><span style="color:#E1E4E8">  src_vocab_table </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> lookup_ops.index_table_from_file(</span></span>
<span class="line"><span style="color:#E1E4E8">      src_vocab_file, </span><span style="color:#FFAB70">default_value</span><span style="color:#F97583">=</span><span style="color:#79B8FF">UNK_ID</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> share_vocab:</span></span>
<span class="line"><span style="color:#E1E4E8">    tgt_vocab_table </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> src_vocab_table</span></span>
<span class="line"><span style="color:#F97583">  else</span><span style="color:#E1E4E8">:</span></span>
<span class="line"><span style="color:#E1E4E8">    tgt_vocab_table </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> lookup_ops.index_table_from_file(</span></span>
<span class="line"><span style="color:#E1E4E8">        tgt_vocab_file, </span><span style="color:#FFAB70">default_value</span><span style="color:#F97583">=</span><span style="color:#79B8FF">UNK_ID</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> src_vocab_table, tgt_vocab_table</span></span>
<span class="line"></span></code></pre>
<p>使用了tensorflow库中定义的lookup_ops，简化了产生字典的操作</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="python"><code><span class="line"><span style="color:#F97583">if</span><span style="color:#F97583"> not</span><span style="color:#E1E4E8"> output_buffer_size:</span></span>
<span class="line"><span style="color:#E1E4E8">    output_buffer_size </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> batch_size </span><span style="color:#F97583">*</span><span style="color:#79B8FF"> 1000</span></span>
<span class="line"><span style="color:#E1E4E8">  src_eos_id </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> tf.cast(src_vocab_table.lookup(tf.constant(eos)), tf.int32)</span></span>
<span class="line"><span style="color:#E1E4E8">  tgt_sos_id </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> tf.cast(tgt_vocab_table.lookup(tf.constant(sos)), tf.int32)</span></span>
<span class="line"><span style="color:#E1E4E8">  tgt_eos_id </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> tf.cast(tgt_vocab_table.lookup(tf.constant(eos)), tf.int32)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D"># 通过zip操作将源数据集和目标数据集合并在一起</span></span>
<span class="line"><span style="color:#6A737D"># 此时的张量变化 [src_dataset] + [tgt_dataset] ---> [src_dataset, tgt_dataset]</span></span>
<span class="line"><span style="color:#E1E4E8">  src_tgt_dataset </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> tf.data.Dataset.zip((src_dataset, tgt_dataset))</span></span>
<span class="line"><span style="color:#6A737D"># 数据集分片，分布式训练的时候可以分片来提高训练速度</span></span>
<span class="line"><span style="color:#E1E4E8">  src_tgt_dataset </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> src_tgt_dataset.shard(num_shards, shard_index)</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> skip_count </span><span style="color:#F97583">is</span><span style="color:#F97583"> not</span><span style="color:#79B8FF"> None</span><span style="color:#E1E4E8">:</span></span>
<span class="line"><span style="color:#E1E4E8">    src_tgt_dataset </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> src_tgt_dataset.skip(skip_count)</span></span>
<span class="line"><span style="color:#6A737D"># 随机打乱数据，切断相邻数据之间的联系</span></span>
<span class="line"><span style="color:#6A737D"># 根据文档，该步骤要尽早完成，完成该步骤之后在进行其他的数据集操作</span></span>
<span class="line"><span style="color:#E1E4E8">  src_tgt_dataset </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> src_tgt_dataset.shuffle(</span></span>
<span class="line"><span style="color:#E1E4E8">      output_buffer_size, random_seed, reshuffle_each_iteration)</span></span>
<span class="line"><span style="color:#E1E4E8">    </span></span>
<span class="line"><span style="color:#6A737D">  # 将每一行数据，根据“空格”切分开来</span></span>
<span class="line"><span style="color:#6A737D">  # 这个步骤可以并发处理，用num_parallel_calls指定并发量</span></span>
<span class="line"><span style="color:#6A737D">  # 通过prefetch来预获取一定数据到缓冲区，提升数据吞吐能力</span></span>
<span class="line"><span style="color:#6A737D">  # 张量变化举例 ['上海　浦东', '上海　浦东'] ---> [['上海', '浦东'], ['上海', '浦东']]</span></span>
<span class="line"><span style="color:#E1E4E8">  src_tgt_dataset </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> src_tgt_dataset.map(</span></span>
<span class="line"><span style="color:#F97583">      lambda</span><span style="color:#E1E4E8"> src, tgt: (</span></span>
<span class="line"><span style="color:#E1E4E8">          tf.string_split([src]).values, tf.string_split([tgt]).values),</span></span>
<span class="line"><span style="color:#FFAB70">      num_parallel_calls</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">num_parallel_calls).prefetch(output_buffer_size)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">  # Filter zero length input sequences.</span></span>
<span class="line"><span style="color:#E1E4E8">  src_tgt_dataset </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> src_tgt_dataset.filter(</span></span>
<span class="line"><span style="color:#F97583">      lambda</span><span style="color:#E1E4E8"> src, tgt: tf.logical_and(tf.size(src) </span><span style="color:#F97583">></span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">, tf.size(tgt) </span><span style="color:#F97583">></span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">))</span></span>
<span class="line"><span style="color:#6A737D"># 限制源数据最大长度</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> src_max_len:</span></span>
<span class="line"><span style="color:#E1E4E8">    src_tgt_dataset </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> src_tgt_dataset.map(</span></span>
<span class="line"><span style="color:#F97583">        lambda</span><span style="color:#E1E4E8"> src, tgt: (src[:src_max_len], tgt),</span></span>
<span class="line"><span style="color:#FFAB70">        num_parallel_calls</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">num_parallel_calls).prefetch(output_buffer_size)</span></span>
<span class="line"><span style="color:#6A737D">  # 限制目标数据的最大长度</span></span>
<span class="line"><span style="color:#F97583">  if</span><span style="color:#E1E4E8"> tgt_max_len:</span></span>
<span class="line"><span style="color:#E1E4E8">    src_tgt_dataset </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> src_tgt_dataset.map(</span></span>
<span class="line"><span style="color:#F97583">        lambda</span><span style="color:#E1E4E8"> src, tgt: (src, tgt[:tgt_max_len]),</span></span>
<span class="line"><span style="color:#FFAB70">        num_parallel_calls</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">num_parallel_calls).prefetch(output_buffer_size)</span></span>
<span class="line"><span style="color:#6A737D">  # Convert the word strings to ids.  Word strings that are not in the</span></span>
<span class="line"><span style="color:#6A737D">  # vocab get the lookup table's default_value integer.</span></span>
<span class="line"><span style="color:#6A737D">  # 通过map操作将字符串转换为数字</span></span>
<span class="line"><span style="color:#6A737D">  # 张量变化举例 [['上海', '浦东'], ['上海', '浦东']] ---> [[1, 2], [1, 2]]</span></span>
<span class="line"><span style="color:#E1E4E8">  src_tgt_dataset </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> src_tgt_dataset.map(</span></span>
<span class="line"><span style="color:#F97583">      lambda</span><span style="color:#E1E4E8"> src, tgt: (tf.cast(src_vocab_table.lookup(src), tf.int32),</span></span>
<span class="line"><span style="color:#E1E4E8">                        tf.cast(tgt_vocab_table.lookup(tgt), tf.int32)),</span></span>
<span class="line"><span style="color:#FFAB70">      num_parallel_calls</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">num_parallel_calls).prefetch(output_buffer_size)</span></span>
<span class="line"><span style="color:#6A737D">  # Create a tgt_input prefixed with &#x3C;sos> and a tgt_output suffixed with &#x3C;eos>.</span></span>
<span class="line"><span style="color:#E1E4E8">  </span></span>
<span class="line"><span style="color:#6A737D">  # 给目标数据加上 sos, eos　标记</span></span>
<span class="line"><span style="color:#6A737D">  # 张量变化举例 [[1, 2], [1, 2]] ---> [[1, 2], [sos_id, 1, 2], [1, 2, eos_id]]</span></span>
<span class="line"><span style="color:#E1E4E8">  src_tgt_dataset </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> src_tgt_dataset.map(</span></span>
<span class="line"><span style="color:#F97583">      lambda</span><span style="color:#E1E4E8"> src, tgt: (src,</span></span>
<span class="line"><span style="color:#E1E4E8">                        tf.concat(([tgt_sos_id], tgt), </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">),</span></span>
<span class="line"><span style="color:#E1E4E8">                        tf.concat((tgt, [tgt_eos_id]), </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">)),</span></span>
<span class="line"><span style="color:#FFAB70">      num_parallel_calls</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">num_parallel_calls).prefetch(output_buffer_size)</span></span>
<span class="line"><span style="color:#6A737D">  # Add in sequence lengths.</span></span>
<span class="line"><span style="color:#6A737D">  # 增加长度信息</span></span>
<span class="line"><span style="color:#6A737D">  # 张量变化举例 [[1, 2], [sos_id, 1, 2], [1, 2, eos_id]] ---> [[1, 2], [sos_id, 1, 2], [1, 2, eos_id], [src_size], [tgt_size]]</span></span>
<span class="line"><span style="color:#E1E4E8">  src_tgt_dataset </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> src_tgt_dataset.map(</span></span>
<span class="line"><span style="color:#F97583">      lambda</span><span style="color:#E1E4E8"> src, tgt_in, tgt_out: (</span></span>
<span class="line"><span style="color:#E1E4E8">          src, tgt_in, tgt_out, tf.size(src), tf.size(tgt_in)),</span></span>
<span class="line"><span style="color:#FFAB70">      num_parallel_calls</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">num_parallel_calls).prefetch(output_buffer_size)</span></span>
<span class="line"></span></code></pre>
<p>处理过程分析：</p>
<ol>
<li>
<p>开始标记和结束标记，转换成为int32</p>
</li>
<li>
<p>关于增加sos以及eos标记，为啥src和target添加的标记不同？</p>
</li>
<li>
<p>关于增加长度信息的意义？</p>
<p>​</p>
</li>
</ol>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="python"><code><span class="line"><span style="color:#6A737D"># 数据对齐</span></span>
<span class="line"><span style="color:#6A737D"># 参数x实际上就是我们的 dataset 对象</span></span>
<span class="line"><span style="color:#F97583">def</span><span style="color:#B392F0"> batching_func</span><span style="color:#E1E4E8">(x):</span></span>
<span class="line"><span style="color:#6A737D">    # 调用dataset的padded_batch方法，对齐的同时，也对数据集进行分批</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> x.padded_batch(</span></span>
<span class="line"><span style="color:#E1E4E8">        batch_size,</span></span>
<span class="line"><span style="color:#6A737D">        # 对齐数据的形状</span></span>
<span class="line"><span style="color:#FFAB70">        padded_shapes</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#6A737D">            # 因为数据长度不定，因此设置None</span></span>
<span class="line"><span style="color:#E1E4E8">            tf.TensorShape([</span><span style="color:#79B8FF">None</span><span style="color:#E1E4E8">]),  </span><span style="color:#6A737D"># src</span></span>
<span class="line"><span style="color:#6A737D">            # 因为数据长度不定，因此设置None</span></span>
<span class="line"><span style="color:#E1E4E8">            tf.TensorShape([</span><span style="color:#79B8FF">None</span><span style="color:#E1E4E8">]),  </span><span style="color:#6A737D"># tgt_input</span></span>
<span class="line"><span style="color:#6A737D">            # 因为数据长度不定，因此设置None</span></span>
<span class="line"><span style="color:#E1E4E8">            tf.TensorShape([</span><span style="color:#79B8FF">None</span><span style="color:#E1E4E8">]),  </span><span style="color:#6A737D"># tgt_output</span></span>
<span class="line"><span style="color:#6A737D">            # 数据长度张量，实际上不需要对齐</span></span>
<span class="line"><span style="color:#E1E4E8">            tf.TensorShape([]),  </span><span style="color:#6A737D"># src_len</span></span>
<span class="line"><span style="color:#E1E4E8">            tf.TensorShape([])),  </span><span style="color:#6A737D"># tgt_len</span></span>
<span class="line"><span style="color:#6A737D">        # 对齐数据的值</span></span>
<span class="line"><span style="color:#FFAB70">        padding_values</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">(</span></span>
<span class="line"><span style="color:#6A737D">            # 用src_eos_id填充到 src 的末尾</span></span>
<span class="line"><span style="color:#E1E4E8">            src_eos_id,  </span><span style="color:#6A737D"># src</span></span>
<span class="line"><span style="color:#6A737D">            # 用tgt_eos_id填充到 tgt_input 的末尾</span></span>
<span class="line"><span style="color:#E1E4E8">            tgt_eos_id,  </span><span style="color:#6A737D"># tgt_input</span></span>
<span class="line"><span style="color:#6A737D">            # 用tgt_eos_id填充到 tgt_output 的末尾</span></span>
<span class="line"><span style="color:#E1E4E8">            tgt_eos_id,  </span><span style="color:#6A737D"># tgt_output</span></span>
<span class="line"><span style="color:#79B8FF">            0</span><span style="color:#E1E4E8">,  </span><span style="color:#6A737D"># src_len -- unused</span></span>
<span class="line"><span style="color:#79B8FF">            0</span><span style="color:#E1E4E8">))  </span><span style="color:#6A737D"># tgt_len -- unused</span></span>
<span class="line"></span></code></pre>
<p>这个数据对齐，没看懂。。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="python"><code><span class="line"><span style="color:#F97583"> if</span><span style="color:#E1E4E8"> num_buckets </span><span style="color:#F97583">></span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">:</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    def</span><span style="color:#B392F0"> key_func</span><span style="color:#E1E4E8">(unused_1, unused_2, unused_3, src_len, tgt_len):</span></span>
<span class="line"><span style="color:#6A737D">      # Calculate bucket_width by maximum source sequence length.</span></span>
<span class="line"><span style="color:#6A737D">      # Pairs with length [0, bucket_width) go to bucket 0, length</span></span>
<span class="line"><span style="color:#6A737D">      # [bucket_width, 2 * bucket_width) go to bucket 1, etc.  Pairs with length</span></span>
<span class="line"><span style="color:#6A737D">      # over ((num_bucket-1) * bucket_width) words all go into the last bucket.</span></span>
<span class="line"><span style="color:#F97583">      if</span><span style="color:#E1E4E8"> src_max_len:</span></span>
<span class="line"><span style="color:#E1E4E8">        bucket_width </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (src_max_len </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> num_buckets </span><span style="color:#F97583">-</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">//</span><span style="color:#E1E4E8"> num_buckets</span></span>
<span class="line"><span style="color:#F97583">      else</span><span style="color:#E1E4E8">:</span></span>
<span class="line"><span style="color:#E1E4E8">        bucket_width </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 10</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">      # Bucket sentence pairs by the length of their source sentence and target</span></span>
<span class="line"><span style="color:#6A737D">      # sentence.</span></span>
<span class="line"><span style="color:#E1E4E8">      bucket_id </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> tf.maximum(src_len </span><span style="color:#F97583">//</span><span style="color:#E1E4E8"> bucket_width, tgt_len </span><span style="color:#F97583">//</span><span style="color:#E1E4E8"> bucket_width)</span></span>
<span class="line"><span style="color:#F97583">      return</span><span style="color:#E1E4E8"> tf.to_int64(tf.minimum(num_buckets, bucket_id))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    def</span><span style="color:#B392F0"> reduce_func</span><span style="color:#E1E4E8">(unused_key, windowed_data):</span></span>
<span class="line"><span style="color:#F97583">      return</span><span style="color:#E1E4E8"> batching_func(windowed_data)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">    batched_dataset </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> src_tgt_dataset.apply(</span></span>
<span class="line"><span style="color:#E1E4E8">        tf.contrib.data.group_by_window(</span></span>
<span class="line"><span style="color:#FFAB70">            key_func</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">key_func, </span><span style="color:#FFAB70">reduce_func</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">reduce_func, </span><span style="color:#FFAB70">window_size</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">batch_size))</span></span>
<span class="line"><span style="color:#F97583">  else</span><span style="color:#E1E4E8">:</span></span>
<span class="line"><span style="color:#E1E4E8">    batched_dataset </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> batching_func(src_tgt_dataset)</span></span>
<span class="line"></span></code></pre>
<p>关于分桶操作，得到的结果，就是相似长度的数据放在一起，能够提升计算效率！！</p>
<p>使用迭代器获取处理之后的数据</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="python"><code><span class="line"><span style="color:#E1E4E8"> batched_iter </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> batched_dataset.make_initializable_iterator()</span></span>
<span class="line"><span style="color:#E1E4E8">  (src_ids, tgt_input_ids, tgt_output_ids, src_seq_len,</span></span>
<span class="line"><span style="color:#E1E4E8">   tgt_seq_len) </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (batched_iter.get_next())</span></span>
<span class="line"></span></code></pre> </article>  </div>  </main> <footer class="animate" data-astro-cid-sz7xmlte> <div class="mx-auto max-w-screen-sm px-5">  <div class="flex justify-between items-center" data-astro-cid-sz7xmlte> <div data-astro-cid-sz7xmlte>
&copy; 2026 | Blog
</div> <div class="flex flex-wrap gap-1 items-center" data-astro-cid-sz7xmlte> <button id="light-theme-button" aria-label="Light theme" class="group size-8 flex items-center justify-center rounded-full" data-astro-cid-sz7xmlte> <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="group-hover:stroke-black group-hover:dark:stroke-white transition-colors duration-300 ease-in-out" data-astro-cid-sz7xmlte> <circle cx="12" cy="12" r="5" data-astro-cid-sz7xmlte></circle> <line x1="12" y1="1" x2="12" y2="3" data-astro-cid-sz7xmlte></line> <line x1="12" y1="21" x2="12" y2="23" data-astro-cid-sz7xmlte></line> <line x1="4.22" y1="4.22" x2="5.64" y2="5.64" data-astro-cid-sz7xmlte></line> <line x1="18.36" y1="18.36" x2="19.78" y2="19.78" data-astro-cid-sz7xmlte></line> <line x1="1" y1="12" x2="3" y2="12" data-astro-cid-sz7xmlte></line> <line x1="21" y1="12" x2="23" y2="12" data-astro-cid-sz7xmlte></line> <line x1="4.22" y1="19.78" x2="5.64" y2="18.36" data-astro-cid-sz7xmlte></line> <line x1="18.36" y1="5.64" x2="19.78" y2="4.22" data-astro-cid-sz7xmlte></line> </svg> </button> <button id="dark-theme-button" aria-label="Dark theme" class="group size-8 flex items-center justify-center rounded-full" data-astro-cid-sz7xmlte> <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="group-hover:stroke-black group-hover:dark:stroke-white transition-colors duration-300 ease-in-out" data-astro-cid-sz7xmlte> <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" data-astro-cid-sz7xmlte></path> </svg> </button> <button id="system-theme-button" aria-label="System theme" class="group size-8 flex items-center justify-center rounded-full" data-astro-cid-sz7xmlte> <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="group-hover:stroke-black group-hover:dark:stroke-white transition-colors duration-300 ease-in-out" data-astro-cid-sz7xmlte> <rect x="2" y="3" width="20" height="14" rx="2" ry="2" data-astro-cid-sz7xmlte></rect> <line x1="8" y1="21" x2="16" y2="21" data-astro-cid-sz7xmlte></line> <line x1="12" y1="17" x2="12" y2="21" data-astro-cid-sz7xmlte></line> </svg> </button> </div> </div>  </div> </footer>  <script>
  function setTheme(theme) {
    document.documentElement.classList.remove("light", "dark", "system");
    
    if (theme === "system") {
      document.documentElement.classList.add("system");
      const systemTheme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
      document.documentElement.classList.add(systemTheme);
    } else {
      document.documentElement.classList.add(theme);
    }
    
    localStorage.setItem("theme", theme);
  }

  document.getElementById("light-theme-button")?.addEventListener("click", () => setTheme("light"));
  document.getElementById("dark-theme-button")?.addEventListener("click", () => setTheme("dark"));
  document.getElementById("system-theme-button")?.addEventListener("click", () => setTheme("system"));

  const savedTheme = localStorage.getItem("theme") || "system";
  setTheme(savedTheme);
</script>  </body> </html>